/* This file is auto-generated by Convex. It should not be edited manually. */

/**
 * This is the server-side entry point for your Convex functions.
 *
 * It is used to run queries and mutations and provides access to the Convex
 * database.
 *
 * @module
 */

import type { DataModel } from "./api";

/**
 * A query or mutation function running on the server.
 */
export declare abstract class ConvexFunction<Args extends any[], Output> {
  /**
   * Call the function with the given arguments.
   */
  abstract __call__(...args: Args): Promise<Output>;
}

/**
 * Define a query function.
 *
 * Query functions load data and are typically called automatically when used
 * with the useQuery hook.
 *
 * Query functions must:
 * 1. Be exported from a file in the /convex directory
 * 2. Use the 'v' validator from convex/values to validate its arguments.
 * 3. Be registered in convex.json
 *
 * @param func - The query function, typically defined as an arrow function with
 * destructured arguments like:
 * ```ts
 * export default query({
 *   args: {
 *     name: v.string(),
 *   },
 *   handler: async ({db}, {name}) => {...}
 * });
 * ```
 * @returns The query function.
 */
export declare function query<
  FilterA extends {
    [key: string]: any;
  },
  Output
>(func: {
  args?: FilterA;
  handler: (ctx: QueryCtx, args: ValidatedQuery<FilterA>) => Promise<Output> | Output;
}): ConvexFunction<[Partial<any>], Output>;

/**
 * Define a mutation function.
 *
 * Mutation functions modify data and are not called automatically with the React
 * hooks. Instead, they are called imperatively to request a change to the
 * database.
 *
 * Mutation functions must:
 * 1. Be exported from a file in the /convex directory
 * 2. Use the 'v' validator from convex/values to validate its arguments.
 * 3. Be registered in convex.json
 *
 * @param func - The mutation function, typically defined as an arrow function with
 * destructured arguments like:
 * ```ts
 * export default mutation({
 *   args: {
 *     name: v.string(),
 *   },
 *   handler: async ({db}, {name}) => {...}
 * });
 * ```
 * @returns The mutation function.
 */
export declare function mutation<
  FilterA extends {
    [key: string]: any;
  },
  Output
>(func: {
  args?: FilterA;
  handler: (
    ctx: MutationCtx,
    args: ValidatedMutation<FilterA>
  ) => Promise<Output> | Output;
}): ConvexFunction<[Partial<any>], Output>;

/**
 * The context available in query functions.
 */
export declare interface QueryCtx {
  /**
   * An object to read data from the database.
   */
  readonly db: DatabaseReader;
}

/**
 * The context available in mutation functions.
 */
export declare interface MutationCtx {
  /**
   * An object to read and write to the database.
   */
  readonly db: DatabaseWriter;
}

/**
 * An interface to read from the database.
 */
export declare interface DatabaseReader {
  /**
   * Retrieve a record by its ID.
   *
   * @param id - The ID or Reference for the document to retrieve.
   * @returns A Promise for the record.
   */
  get<Table extends keyof DataModel & string>(
    id: string
  ): Promise<null | (DataModel[Table] & { _id: string })>;

  /**
   * Query for records.
   *
   * @param table - The name of the table to be queried.
   * @returns A {@link GenericQueryInitializer} for the specified table.
   */
  query<TableName extends keyof DataModel & string>(
    table: TableName
  ): GenericQueryInitializer<TableName>;
}

/**
 * An interface to read from and write to the database.
 */
export declare interface DatabaseWriter extends DatabaseReader {
  /**
   * Insert a new record into a table.
   *
   * @param table - The name of the table to be inserted into.
   * @param value - The record to insert.
   * @returns A promise that resolves to the ID of the inserted record.
   */
  insert<TableName extends keyof DataModel & string>(
    table: TableName,
    value: DataModel[TableName]
  ): Promise<string>;

  /**
   * Patch an existing document with a partial update.
   *
   * @param id - The ID of the document to patch.
   * @param value - The partial update to apply to the document.
   * @returns A Promise for the patched document.
   */
  patch<TableName extends keyof DataModel & string>(
    id: string,
    value: Partial<DataModel[TableName]>
  ): Promise<string>;

  /**
   * Delete an existing document.
   *
   * @param id - The ID of the document to delete.
   * @returns A Promise for the deleted document.
   */
  delete(id: string): Promise<string>;
}

/**
 * A builder to query for records.
 *
 * This is typically used in a function call chain, ending with a collection function.
 */
export declare interface GenericQueryInitializer<TableName extends keyof DataModel & string> {
  /**
   * Filter for a subset of documents in this query's table using a filter function.
   *
   * @param q - A function that takes a query and returns a filter expression.
   * @returns A reference to the same query, filtered.
   */
  filter(
    q: (q: GenericFilterBuilder<TableName>) => GenericFilterExpression<TableName>
  ): GenericQueryInitializer<TableName>;

  /**
   * Execute the query and get all of the results.
   *
   * @returns A promise for an array of documents that match the query.
   */
  collect(): Promise<Array<DataModel[TableName] & { _id: string }>>;

  /**
   * Execute the query and get the first result.
   *
   * @returns A promise for the first document that matches the query, or null if there are no matching documents.
   */
  first(): Promise<(DataModel[TableName] & { _id: string }) | null>;

  /**
   * Set the order for this query's results.
   *
   * @param direction - The order. Can be 'asc' or 'desc'.
   * @param q - function that takes a FieldPaths instance and returns a field path string or an array of field path strings. For example, either `(fields) => fields.name` or `(fields) => fields._creationTime`.
   * @returns A reference to the same query, with new order.
   */
  order(
    direction: "asc" | "desc",
    q: (fields: FieldPaths<TableName>) => string
  ): GenericQueryInitializer<TableName>;
}

/**
 * A filter expression can be created using a {@link GenericFilterBuilder}.
 *
 * It can be combined with other filter expressions using `and` and `or`.
 */
export declare interface GenericFilterExpression<TableName extends keyof DataModel & string> {
  /**
   * Combine two filter expressions, requiring both to be true.
   *
   * @param other - Another filter expression.
   * @returns The combined filter expression.
   */
  and(
    other: GenericFilterExpression<TableName>
  ): GenericFilterExpression<TableName>;

  /**
   * Combine two filter expressions, requiring at least one to be true.
   *
   * @param other - Another filter expression.
   * @returns The combined filter expression.
   */
  or(
    other: GenericFilterExpression<TableName>
  ): GenericFilterExpression<TableName>;
}

/**
 * A builder for query filter expressions.
 */
export declare interface GenericFilterBuilder<TableName extends keyof DataModel & string> {
  /**
   * Create a filter expression comparing a field to a value.
   *
   * @param op - The comparison operation.
   * @param field - The field to compare, constructed using methods on this
   * `GenericFilterBuilder` like `q.field("fieldName")` or
   * `q.field("fieldName1").field("fieldName2")`.
   * @param value - The value to compare to.
   * @returns A filter expression.
   */
  eq<FieldValue>(
    field: GenericField<TableName, FieldValue>,
    value: FieldValue
  ): GenericFilterExpression<TableName>;

  /**
   * Get a field out of a filter builder, for use with comparison filter expressions.
   *
   * @param name - The field name.
   * @returns A field object.
   */
  field<FieldName extends keyof DataModel[TableName] & string>(
    name: FieldName
  ): GenericField<TableName, DataModel[TableName][FieldName]>;
}

/**
 * A field object, for use with comparison filter expressions.
 */
export declare interface GenericField<
  TableName extends keyof DataModel & string,
  FieldType
> {}

/**
 * A field path generator, for use with `order`.
 */
export declare interface FieldPaths<TableName extends keyof DataModel & string> {
  [FieldName: string]: any;
}

/**
 * The available validators.
 */
export declare interface Validators {
  /**
   * Allow any value to be passed in and use TypeScript to narrow it.
   *
   * This is unsafe! It is always possible to pass in a mistyped value
   * at runtime to a function.
   *
   * @param description - A description of the value for use in error messages.
   * @returns A validator for any value.
   */
  any(): null;

  /**
   * Validate that the input is null.
   *
   * @returns A validator for the value `null`.
   */
  null(): null;

  /**
   * Validate that the input is a boolean.
   *
   * @returns A validator for boolean values.
   */
  boolean(): boolean;

  /**
   * Validate that the input is a number.
   *
   * @returns A validator for number values.
   */
  number(): number;

  /**
   * Validate that the input is a string.
   *
   * @returns A validator for string values.
   */
  string(): string;

  /**
   * Validate that the input is an array with elements matching the given type.
   *
   * @param elementType - A validator for the elements of the array.
   * @returns A validator for arrays containing elements with the given type.
   */
  array<T>(elementType: T): T[];

  /**
   * Validate that the input is an object with a particular schema.
   *
   * This allows multiple fields, each with its own type.
   *
   * @param schema - A record mapping from field name to validator.
   * @returns A validator for objects with the given schema.
   */
  object<T extends {}>(schema: T): ValidatorFromObject<T>;

  /**
   * Validate that the input matches any of a union of types.
   *
   * @param types - The validators that are allowed for this value.
   * @returns A validator for values matching any of the listed types.
   */
  union<A, B extends any[]>(type1: A, ...types: B): A | UnionToIntersection<B[number]>;
}

export declare type ValidatorFromObject<T extends {}> = {
  [K in keyof T]: T[K] extends any[] ? T[K] : T[K] extends object ? any : T[K];
};

/**
 * A union of validators produces an intersection of their types.
 */
export declare type UnionToIntersection<U> = (
  U extends any ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never;

/**
 * Schema validator.
 */
export declare const v: Validators;

/**
 * Create a type corresponding to the output type of a query validator object.
 */
export declare type ValidatedQuery<T> = {
  [K in keyof T]: any;
};

/**
 * Create a type corresponding to the output type of a mutation validator object.
 */
export declare type ValidatedMutation<T> = {
  [K in keyof T]: any;
};